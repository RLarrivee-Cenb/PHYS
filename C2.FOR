CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C	LINK CONC_COLLECT,MET_P:CONC_ANVAL/OPT,
C	CRUSH_ANVAL/OPT,D_I:DIGCOMCNC/OPT
C                         
C
C
C
C	REVISION OF 29-NOV-1994
C
C	CARRY DELAYS FROM ONE SHIFT TO THE NEXT
C	
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	IMPLICIT NONE
C
	INTEGER UFO_OPEN,DCNT,LN,NC,MSAVE,HS,SAVEINDEX(2),XMM,MSGCNT
C
	EXTERNAL UFO_OPEN
C
c	   weighting factor for recovery  (no. of lines/ by step)
	REAL WFACT(3)/3,6,6/
C
	CHARACTER SAVMD*40,MX(168)*40
C
	CHARACTER*23 ENDATE(42),STPTM,STRTM
	REAL XBAR,UCL,LCL,UCLR,XVAL(43),RVAL(43),XSUM(18),INDNC(16)
	CHARACTER ASTT*23,BDAY*23,SAVE*64,ALN*2
	INTEGER XDAT(2),DAT2(2),INTC,INTF,R,ST(2),BONE(2),INTV(2),LA,LB,
	1	XDATX(2),DAT2X(2),INTCX,INTFX,LRB,LRE
	DOUBLE PRECISION CT(16,12),FT(7,3),CTX(16,12),FTX(7,3)
	REAL	REALTIME,RR,CL
C
	CHARACTER ADAY*23,AONE/'1'/
C
	INTEGER GOODPT(60),GOODPTCR(40),I,J,K,L,M,N,NN,MM,CXSTS(100)
	REAL ANVAL(1900),ANVALCR(1000),SUM,NSUM
C
	INTEGER*2 STAT
C
c
c
C
c
	structure /bozo2/
c
		character*4	key		! yymm	(primary key)
		real		msil(3,31)	! mine ind. sio2 by shift,day
		real		cr12(3,31)	! crusher +1/2 by shift,day
		real 		flfr(3,31)	! flf davis tube recovery
		real		flfs(3,31)	! flf davis tube sio2
		real		fls(3,31)	! flf sio2
		real		flts(3,31)	! flot tails sio2
		real		aeff(4,3,31)	! amine efficiency by cell
c
c
	end structure
c
	record /bozo2/ hsd
C
c
c
c
	STRUCTURE /SHIFT/
C
		CHARACTER 	DS*7		! 1-6=YYMMDD  7=SHIFT   (KEY 0)
		INTEGER		INPTIME(2)	! INPUT TIME
		CHARACTER 	FOREMAN*14
		CHARACTER 	TL*14
		CHARACTER 	OPER*14
C
		REAL		TPH(18)
		REAL		LGRIND(18)
		REAL 		OPHRS(18)
C
		INTEGER		INDEX(2,40)
		CHARACTER	DELAYS(40)*64
C
		REAL		GRINDS(3)
		REAL		CNOLA(3)
		REAL		SIL(3)
		REAL		TARG(3)
		REAL		RECV(3)
		REAL		BINS(3)
		REAL		RAW(2)
		REAL		FLOC(3)
		INTEGER		DOWN(18)	! 1=DOWN
		REAL		FLSIL
		REAL		FLFE
		REAL		AMINE
		INTEGER		BANKS(4)	! 1=DOWN
		REAL		FLREC
		REAL		CT
		REAL		FT
		INTEGER		LR		! LINES RUNNING
		REAL		AL		! AVERAGE LINES
		INTEGER		FPLUGS
		INTEGER		DIKE
		INTEGER		PIT
		CHARACTER	RES*5
		INTEGER		FLXBINLVL
		CHARACTER*4	FROTHSTAT
		INTEGER 	FLUXSTAT
		INTEGER		FLXTM(2)
		CHARACTER*3	AGBINS(5)
		INTEGER		AGTANKS(6)
		LOGICAL		SPC2,SPC3
C
		CHARACTER	MFLOSS*80
		CHARACTER	HKEEP(3)*80
		LOGICAL		SAFE
		CHARACTER	SAFEMSG*160
		CHARACTER	UTIL(3)*80
		CHARACTER	CTPROB(3)*80
C
		CHARACTER	MDOWN(168)*40
C
		INTEGER  	SST(2,2,16,20)         ! STOP TIME, START TIME
c
		REAL	       	REALTIME	 !time since beginning of shift
		LOGICAL		SPC2S,SPC3S	!in control for shift
C
		REAL		RRATIO		!RECOVERY RATIO
		REAL		LFT(7)		!FINE TAILS BY SECTION
		REAL		LCT(18)		!COARSE TAILS BY LINE
		CHARACTER	MFLOSS2*80   !added to mag loss by rjs 14mar94
		INTEGER		RGONOFF		!1-MILL ON 0-MILL OFF
		REAL		RGPOP		!%OP TIME RGRND MILL 
		REAL		FTC(8)	     !%froth to cyc.- max 8entry/shift
		REAL		FTCH(8)	     !hours for each entry
		REAL		LIMESTONE	!SHIFT LIMESTONE TONS
		REAL		LIMEGRIND	!LAST -200 GRIND FOR LIMESTONE
	END STRUCTURE
C
	RECORD /SHIFT/ DAT,DATX2,DATZ
C
C
C
C		CX AND ANALOG POINTS FROM CONCENTRATOR VXI
C
	INTEGER  TPH(18)/0,0,50,162,190,208,238,256,284,304,331,351,389,
	1			412,452,472,507,527/,
	1	LGRIND(18)/0,0,957,959,961,963,964,966,968,970,
	1		  972,974,976,978,980,982,984,986/,
	1	OPHRS(18)/0,0,1501,1502,1503,1504,1505,1506,1507,1508,1509,
	1		  1510,1511,1512,1513,1514,1515,1516/,
	1	GRINDS(3)/1677,1678,1679/,
	1	NSIL(2)/1305,1306/,
	1	TARG(2)/1698,1699/,
	1	RECOV(3)/1663,1664,1665/,
	1	CBIN(2)/456,457/,		!CRUSHER ANALOGS
	1	FLUXBIN/455/,                   !CRUSHER ANALOGS
	1	FFSIL/1312/,
	1	AMINELBT/1203/,
	1	FLOCSPD1(2)/648,691/,FLOCSPD2(3)/699,730,762/,
	1				FLOCSPD3(3)/795,827,855/,
	1	ST2COMP/1755/,ST3COMP/1756/,
	1	RGAN/1614/,RGCX/764/,LIMEAN/850/
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
C
	STRUCTURE /BOB/
		CHARACTER SHIFT	                  ! 1,2, OR 3    KEY
		INTEGER   RMSTAT(16)		  ! 1=UP 0=DOWN  ROD MILL CXS
		INTEGER   SST(2,2,16,20)         ! STOP TIME, START TIME
		INTEGER   FLUXUP                  ! 1=UP,0=DOWN
		INTEGER   FLUXTIME(2)             ! TIME OF LAST STATUS CHANGE
		INTEGER   FLOT(4)			! 1=UP,0=DOWN 
	END STRUCTURE
C
	RECORD /BOB/ DLY,DLYZ
C
C
C
C
	STRUCTURE /SHIFTX/
C
C
	CHARACTER*6 DATES
	INTEGER SHIFT
	INTEGER TANK(6)
	CHARACTER BINS(5)*3
	REAL    PROD(5)
	INTEGER FILOP(3)
	INTEGER FILAV(3)
	INTEGER	VAC(3)
	REAL TRIPH20(3),FILTR(3),TOT203(3),CSIO2(3),RECOV(3),GRIND(3),
	1	BTA(3),RATIO(3),RECI(3),RECO(3),GRATEHR(5),BALLHR(5),
	1	WOODT(5),COALT(5),GASCF(5),PELTYP(5),RECBAL(5),
	1	FORECAST(2),ACTUAL(2),T42
C
	REAL PTONS(5),BENT(5),MBTU(5),BT(5),AT(5),Q(5),CMP(5),M200(5),
	1	BZ(5),KE(5),PRE(5),UGR(5),DD1(5),DD2(5),GSPD(5),BED(5),
	1	HITMP(5),MICRO(5)
C
	CHARACTER EQUIP(5,5)*13,STOP(5,5)*5,START(5,5)*5,MSG(5,5)*40
C
	CHARACTER  MESSAGE(5)*80,SLOP*1550
C
	REAL DMBTU(5)
C
	CHARACTER YR*4
C
	END STRUCTURE
C
C
	RECORD /SHIFTX/ DATA,DATAZ
C
C
	integer aqq(2)
C
C
	INTEGER SHIFT,ICNT,SHIFT2
	CHARACTER ASHIFT,MON(12)*3/'JAN','FEB','MAR','APR','MAY','JUN','JUL',
	1	'AUG','SEP','OCT','NOV','DEC'/,KEY*7,KEY2*7,ASHIFT2
	REAL X,Y,XX,YY
C
C
	CHARACTER SSZ(3)*5/'22:30','06:30','14:30'/,
	1	  ESZ(3)*5/'06:29','14:29','22:29'/
C
	INTEGER IPS,KK,JJ,NSTART,MINUS6
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCC
C
	INTEGER FROTH_ANVAL/1727/
C
CCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
	COMMON /CNC_ANVALTBL/ANVAL,/CNC_GOODPTTBL/GOODPT
	COMMON /CRS_ANVALTBL/ANVALCR,/CRS_GOODPTTBL/GOODPTCR
	COMMON /CONTACTSCNC/CXSTS
C
	CALL SYS$BINTIM (AONE,BONE)
C
	OPEN (UNIT=31,FILE='LOGS:CNC_ACTIVE.DAT',STATUS='OLD',RECL=2,
	1	FORM='UNFORMATTED',ACCESS='DIRECT',USEROPEN=
	1	UFO_OPEN,SHARED)	
C
C
	OPEN (UNIT=32,FILE='LOGS:CNC_HOUR.DAT',STATUS='OLD',RECL=2,
	1	FORM='UNFORMATTED',ACCESS='DIRECT',USEROPEN=
	1	UFO_OPEN,SHARED)	
C
C
C
	OPEN (UNIT=33,FILE='LOGS:CNC_SHIFT.DAT',STATUS='OLD',RECL=2,
	1	FORM='UNFORMATTED',ACCESS='DIRECT',USEROPEN=
	1	UFO_OPEN,SHARED)	
C
C
C
C
C
C
C	   shift report file, this file is in DESCENDING order.
C
	OPEN (UNIT=10,FILE='USER_D:[METREP.CSHIFT]SHIFT_DELAYS2.DAT',
	1	ACCESS='KEYED',STATUS='OLD',SHARED,ERR=7080)
C
	GO TO 887
C
7080	WRITE (6,*) ' CONC SHIFT REPORT IS BEING UPDATED- TRY LATER'
	CALL LIB$WAIT (2.)
	STOP
C
C
C
C	   delay file from shiftgetcn.for  this is updated by hourly.for
c
887	OPEN (UNIT=11,FILE='USER_D:[METREP.CSHIFT]DELAY_TIMES.DAT',
	1	ACCESS='KEYED',FORM='UNFORMATTED',RECL=4000,
	1	STATUS='UNKNOWN',err=8181)
c
	go to 888
C
c	  cnshift has file open because a delay is being split or
c	  because shiftgetcn is running, wait!
8181	CALL LIB$WAIT (1.)
	GO TO 887
C
C
C	  get today's ascii date and time
c
888	CALL SYS$ASCTIM (,ADAY,,)
C
	IF (ADAY(1:1) .EQ. ' ') ADAY(1:1)='0'
C
C
	IF (ADAY(13:17) .GE. '07:30' .AND. ADAY(13:17) .LT. '15:30') THEN
		SHIFT=2
		ASHIFT='2'
	ELSE IF (ADAY(13:17) .GE. '15:30' .AND. ADAY(13:17) .LT. '23:30') THEN
		SHIFT=3
		ASHIFT='3'
	ELSE
		SHIFT=1
		ASHIFT='1'
	END IF
C
C
C
C
C
	IF (SHIFT .EQ. 1) THEN
C
		IF (ADAY(13:14) .EQ. '23') THEN
			call sys$bintim (aday,aqq)
			CALL LIB$ADD_TIMES(AQQ,BONE,AQQ)
			CALL SYS$ASCTIM (,ADAY,AQQ,)
			IF (ADAY(1:1) .EQ. ' ') ADAY(1:1)='0'
		END IF
	END IF
C
	DO 100 I=1,12
		IF (ADAY(4:6) .EQ. MON(I)) GO TO 101
100	CONTINUE
	STOP 'MONTH B.O.'
C
101	WRITE (KEY(3:4),'(I2)')  I
C
	IF (KEY(3:3) .EQ. ' ') KEY(3:3)='0'
C
C
	KEY=ADAY(10:11)//KEY(3:4)//ADAY(1:2)//ASHIFT
C
C
	ICNT=0
C
C
C	  read in the shift storage file
C
C
102	READ (10,KEY=KEY,IOSTAT=MM) DAT
C
	IF (MM .EQ. 36) THEN	!NEW SHIFT, MOVE SOME DATA TO NEXT SHIFT.
		DAT.DS=KEY
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	  get previous shift's data
C
	if (shift .eq. 1) then
	SHIFT2=3
	call sys$bintim (aday,aqq)
	CALL LIB$sub_TIMES(AQQ,BONE,AQQ)
	CALL SYS$ASCTIM (,bDAY,AQQ,)
	IF (BDAY(1:1) .EQ. ' ') BDAY(1:1)='0'
C
	ELSE
C
	BDAY=ADAY
	SHIFT2=SHIFT-1
	END IF
C
	WRITE (ASHIFT2,'(I1)') SHIFT2
C
	DO 1004 I=1,12
		IF (BDAY(4:6) .EQ. MON(I)) GO TO 4101
1004	CONTINUE
	STOP 'MONTH B.O.'
C
4101	WRITE (KEY2(3:4),'(I2)')  I
C
	IF (KEY2(3:3) .EQ. ' ') KEY2(3:3)='0'
C
C
	KEY2=BDAY(10:11)//KEY2(3:4)//BDAY(1:2)//ASHIFT2
C
C
C
C
C	  read in the PREVIOUS SHIFT'S storage file
C
C
	READ (10,KEY=KEY2,ERR=500) DATX2
C
	DO 729 I=1,8
		IF (DATX2.FTC(I) .LT. 0) GO TO 7292
729	CONTINUE
	I=8
	GO TO 7293
7292	IF (I .GT. 1) I=I-1
7293	DAT.FTC(1)=DATX2.FTC(I)
	DO 1414 I=2,8
1414		DAT.FTC(I)=-1.
	DAT.HKEEP(1)=DATX2.HKEEP(1)
	DAT.HKEEP(2)=DATX2.HKEEP(2)
	DAT.HKEEP(3)=DATX2.HKEEP(3)
C
	DAT.UTIL(1)=DATX2.UTIL(1)
	DAT.UTIL(2)=DATX2.UTIL(2)
	DAT.UTIL(3)=DATX2.UTIL(3)
C
	DAT.CTPROB(1)=DATX2.CTPROB(1)
	DAT.CTPROB(2)=DATX2.CTPROB(2)
	DAT.CTPROB(3)=DATX2.CTPROB(3)
C
	DAT.SAFE=DATX2.SAFE
	DAT.SAFEMSG=DATX2.SAFEMSG
C
	DO 242 I=1,168
C
242	DAT.MDOWN(I)=DATX2.MDOWN(I)
C
C
	msgcnt=1
	do 1360 ln=1,16
	do 1361 nc=20,1,-1
c
c		  is there a stop time but no start time?
c
		if (datx2.sst(1,1,ln,nc) .ne. 0 .and. 
	1		datx2.sst(1,2,ln,nc) .eq. 0) then
c								yes
			do 1362 m=1,40
c
				if (datx2.index(1,m) .eq. ln .and.
	1			    datx2.index(2,m) .eq. nc) then
c
				dat.delays(msgcnt)=datx2.delays(m)
				dat.index(1,msgcnt)=ln
				dat.index(2,msgcnt)=1
c
				msgcnt=msgcnt+1
c
				if (msgcnt .gt. 40) msgcnt=40
c
				end if
c
1362			continue
			go to 1360
		end if
c
1361	continue
1360	continue
c
c
	DO 337 I=MSGCNT,40
337	DAT.DELAYS(I)='                                              '
c
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
	ELSE IF (MM .EQ. 52) THEN
		CALL LIB$WAIT (1.)
		ICNT=ICNT+1
		IF (ICNT .EQ. 10) STOP 'RECORD LOCKED'
		GO TO 102
	ELSE
		IF (MM .NE. 0) STOP 'RECORD PROBLEM'
C
C
C
C
	END IF       		!END OF FIRST PASS THRU NEW SHIFT
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
C
500	HS=0
C
	IF (ADAY(13:17) .GT. '06:30' .AND. ADAY(13:17) .LT. '07:30') THEN
C
		HS=1
		ADAY(13:23)='06:30:00.00'
	ELSE IF (ADAY(13:17) .GT. '14:30' .AND. ADAY(13:17) .LT. '15:30') THEN
C
		HS=1
		ADAY(13:23)='14:30:00.00'
C
	ELSE IF (ADAY(13:17) .GT. '22:30' .AND. ADAY(13:17) .LT. '23:30') THEN
C
		HS=1
		ADAY(13:23)='22:30:00.00'
	END IF
C
C
	CALL SYS$BINTIM (ADAY,DAT.INPTIME)
C
C
C
	ICNT=0
C
103	READ (11,KEY=ASHIFT,IOSTAT=NN) DLY
C
	IF (NN .EQ. 36) THEN
		STOP 'conc DELAY FILE DOES NOT EXIST'
	ELSE IF (NN .EQ. 52) THEN
		CALL LIB$WAIT (1.)
		ICNT=ICNT+1
		IF (ICNT .EQ. 10) STOP 'conc DLY RECORD LOCKED'
		GO TO 103
	END IF
C
C
C	  put the delay times from the live file to the save file
C
	DO 120 I=1,2
	DO 120 J=1,2
	DO 120 K=1,16
	DO 120 L=1,20
		DAT.SST(I,J,K,L)=DLY.SST(I,J,K,L)
120	CONTINUE
c
C
C
	DAT.FLUXSTAT=DLY.FLUXUP
	DAT.FLXTM(1)=DLY.FLUXTIME(1)
	DAT.FLXTM(2)=DLY.FLUXTIME(2)
C
C
	DO 56 I=1,4
56		DAT.BANKS(I)=DLY.FLOT(I)
C
C
	M=0
	DO 88 I=1,16
		IF (DLY.RMSTAT(I) .EQ. 1)THEN
			 M=M+1
			dat.down(i+2)=0
		ELSE
			DAT.DOWN(I+2)=1
		END IF
88	CONTINUE
C
	DAT.LR=M
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c
c
	do 121 I=3,18
cccc		IF (I .EQ. 3) GO TO 3120
		DAT.TPH(I)=0
		READ (33,REC=TPH(I)) X,Y
119		READ (31,REC=TPH(I)) XX,YY
		IF (Y+YY .LE. 0) GO TO 3120
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
		DAT.TPH(I)=(X+XX)/(Y+YY)
C
3120		DAT.OPHRS(I)=0
		READ (33,REC=OPHRS(I)) X,Y
		READ (31,REC=OPHRS(I)) XX,YY
		IF (HS.EQ. 1) THEN
			XX=0
			YY=0
		END IF
		IF (Y+YY .LE. 0) GO TO 1211
		DAT.OPHRS(I)=X+XX
C
1211		DAT.LGRIND(I)=0
		READ (33,REC=LGRIND(I)) X,Y
		READ (31,REC=LGRIND(I)) XX,YY
		IF (Y+YY .LE. 0) GO TO 121
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
		DAT.LGRIND(I)=(X+XX)/(Y+YY)
C
121	CONTINUE
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c
C	  calculate time from beginning of shift until now.
c
	call sys$asctim (,astt,dat.inptime,)
c
	IF (SHIFT .EQ. 1) THEN
		IF (ASTT(13:14).GE.'22' .AND. ASTT(13:14).LE.'23') THEN
			ASTT=ASTT(1:12)//'22:30:00.00'
			CALL SYS$BINTIM (ASTT,ST)
		ELSE
			CALL LIB$SUB_TIMES(DAT.INPTIME,BONE,ST)
			CALL SYS$ASCTIM (,ASTT,ST,)
			ASTT=ASTT(1:12)//'22:30:00.00'
			CALL SYS$BINTIM (ASTT,ST)
		END IF
C
	ELSE IF (SHIFT .EQ. 2) THEN
			ASTT=ASTT(1:12)//'06:30:00.00'
			CALL SYS$BINTIM (ASTT,ST)
	ELSE IF (SHIFT .EQ. 3) THEN
			ASTT=ASTT(1:12)//'14:30:00.00'
			CALL SYS$BINTIM (ASTT,ST)
	END IF
c
c	  calculate down-time
c
	call lib$sub_times (dat.inptime,ST,ST)
c
	call sys$ASCtim (,ASTT,st,)
C
	READ (ASTT(6:7),'(F2.0)') REALTIME
C
	READ (ASTT(9:10),'(F2.0)') RR
C
	REALTIME=REALTIME+RR/60.
C
	DAT.REALTIME=REALTIME
ccccccccccccccccccccccccc
c           
	CL=0.
c
	DO 6101 I=1,16
C
6101		CL=CL+DAT.OPHRS(I+2)
C
		DAT.AL=CL/REALTIME
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
	DO 122 I=1,3
		DAT.GRINDS(I)=0
		READ (33,REC=GRINDS(I)) X,Y
		READ (31,REC=GRINDS(I)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
		IF (YY+Y .LE. 0) GO TO 1123
		DAT.GRINDS(I)=(X+XX)/(Y+YY)
C
1123		DAT.RECV(I)=0
		READ (33,REC=RECOV(I)) X,Y
		READ (31,REC=RECOV(I)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
		IF (YY+Y .LE. 0) GO TO 122
		DAT.RECV(I)=(X+XX)/(Y+YY)
122	CONTINUE
C
c
c
C
	DO 130 I=1,2
		DAT.SIL(I+1)=0
		READ (33,REC=NSIL(I)) X,Y
		READ (31,REC=NSIL(I)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
		IF (Y+YY .LE. 0) GO TO 124
		DAT.SIL(I+1)=(X+XX)/(Y+YY)
C
124		DAT.TARG(I+1)=0
		READ (33,REC=TARG(I)) X,Y
		READ (31,REC=TARG(I)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
		IF (Y+YY .LE. 0) GO TO 130
		DAT.TARG(I+1)=(X+XX)/(Y+YY)
130	CONTINUE
C
	DAT.BINS(2)=ANVALCR(CBIN(1))
	DAT.BINS(3)=ANVALCR(CBIN(2))
C
	DAT.FLXBINLVL=ANVALCR(FLUXBIN)
C
	READ (33,REC=FFSIL) X,Y
	IF (Y .NE. 0) DAT.FLSIL=X/Y
C
	DAT.AMINE=0
	READ (33,REC=AMINELBT) X,Y
	READ (31,REC=AMINELBT) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) DAT.AMINE=(X+XX)/(Y+YY)
C
C
CCCCCCCCCCCCCCC
C	  avg flocc. speed  (STEP 1)
C
	SUM=0
	N=0
C
	DAT.FLOC(1)=0
	READ (33,REC=FLOCSPD1(1)) X,Y
	READ (31,REC=FLOCSPD1(1)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) THEN
		N=N+1
		SUM=(X+XX)/(Y+YY)
	END IF
C
	READ (33,REC=FLOCSPD1(2)) X,Y
	READ (31,REC=FLOCSPD1(2)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) THEN
		SUM=SUM+((X+XX)/(Y+YY))
		N=N+1
	END IF
C
	IF (N .NE. 0) DAT.FLOC(1)=SUM/N
C
C
C
C	  avg flocc. speed  (STEP 2)
C
	SUM=0
	N=0
C
	DAT.FLOC(2)=0
	READ (33,REC=FLOCSPD2(1)) X,Y
	READ (31,REC=FLOCSPD2(1)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) THEN
		N=N+1
		SUM=(X+XX)/(Y+YY)
	END IF
C
	READ (33,REC=FLOCSPD2(2)) X,Y
	READ (31,REC=FLOCSPD2(2))XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) THEN
		SUM=SUM+(X+XX)/(Y+YY)
		N=N+1
	END IF
C
	READ (33,REC=FLOCSPD2(3)) X,Y
	READ (31,REC=FLOCSPD2(3)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) THEN
		SUM=SUM+(X+XX)/(Y+YY)
		N=N+1
	END IF
C
	IF (N .NE. 0) DAT.FLOC(2)=SUM/N
C
C
C
C	  avg flocc. speed  (STEP 3)
C
	SUM=0
	N=0
C
	DAT.FLOC(3)=0
	READ (33,REC=FLOCSPD3(1)) X,Y
	READ (31,REC=FLOCSPD3(1)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) THEN
		N=N+1
		SUM=(X+XX)/(Y+YY)
	END IF
C
	READ (33,REC=FLOCSPD3(2)) X,Y
	READ (31,REC=FLOCSPD3(2)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) THEN
		N=N+1
		SUM=SUM+((X+XX)/(Y+YY))
	END IF
C
	READ (33,REC=FLOCSPD3(3)) X,Y
	READ (31,REC=FLOCSPD3(3)) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) THEN
		N=N+1
		SUM=SUM+((X+XX)/(Y+YY))
	END IF
C
	IF (N .NE. 0) DAT.FLOC(3)=SUM/N
C
C
C	   determine which nola is controlling which step
c
	DAT.CNOLA(2)=2
	IF (STAT(ST2COMP)) DAT.CNOLA(2)=3
	DAT.CNOLA(3)=2
	IF (STAT(ST3COMP)) DAT.CNOLA(3)=3
C
C
C
C	   indicate if 130-02 regrind mill is presently operating
C
	DAT.RGONOFF=0
	IF (STAT(RGCX)) DAT.RGONOFF=1
C
C
C	   get shift regrind mill hours
C
	READ (33,REC=RGAN) X,Y
	DAT.RGPOP=X
C
C
	XX=0
	DO 464 I=1,8
		IF (DAT.FTC(I) .LT. 0) GO TO 465
		XX=XX+DAT.FTCH(I)
464	CONTINUE
	I=8
	GO TO 505
C
465	IF (I .LT. 8 .AND. I .GT. 1)I=I-1
505	DAT.FTCH(I)=DAT.REALTIME-XX
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	PUT LATEST FROTH TO CYCLONE PERCENTAGE IN CONCENTRATOR
C	ANVAL TABLE, POINT NO. 1727.  THIS PERCENTAGE IS INPUT
C	BY THE CONC. CONTROL ROOM OPERATOR 
C
	IF (DAT.FTC(I) .LT. 0 .OR. DAT.FTC(I) .GT. 100) GO TO 1918
	JJ=(FROTH_ANVAL/32)+1
	KK=MOD(FROTH_ANVAL,32)
C
	ANVAL(FROTH_ANVAL)=DAT.FTC(I)
	GOODPT(JJ)=JIBSET(GOODPT(JJ),KK)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C	get limestone tons- shift to date
C
C
C
1918	DAT.LIMESTONE=0
	READ (33,REC=LIMEAN) X,Y
	READ (31,REC=LIMEAN) XX,YY
		IF (HS .EQ. 1) THEN
			XX=0
			YY=0
		END IF
	IF (Y+YY .NE. 0) DAT.LIMESTONE=X+XX
C
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
	OPEN (75,FILE='MET_P:AGSHIFT.DAT',FORM='UNFORMATTED',
	1	ACCESS='DIRECT',STATUS='UNKNOWN',RECL=2048,ERR=255)
C
	READ (75,REC=SHIFT,ERR=255) DATA
	CLOSE (75)
C
	DO 300 I=1,5
300	DAT.AGBINS(I)=DATA.BINS(I)
C
	DO 301 I=1,6
301	DAT.AGTANKS(I)=DATA.TANK(I)
C
C
255	CONTINUE
CCCCCCCCCCCCCCC
C
C	  read in coarse and fine tails
C
C
	OPEN (UNIT=60,FILE='USER_D:[METREP.LINEAT]TAILS2.LIS',
	1	STATUS='UNKNOWN',RECL=512,FORM='UNFORMATTED',ACCESS='DIRECT'
	2	,SHARED,USEROPEN=UFO_OPEN)
C
C
	READ (60,ERR=457,REC=1) XDAT,INTC,CT,DAT2,INTF,FT
	READ (60,ERR=457,REC=2) XDATX,INTCX,CTX,DAT2X,INTFX,FTX
C
	CLOSE (60)
C
	NSUM=0
	SUM=0
	LRB=0
	LRE=0
C
	IF (SHIFT .EQ. 1) THEN
		L=1
		R=4
		IF (INTC .LT. 4) THEN
			R=INTC
			LRE=12
			LRB=12-(4-INTC-1)
		END IF
	ELSE IF (SHIFT .EQ. 2) THEN
		L=5
		R=8
		IF (INTC .LT. 8) R=INTC
	ELSE IF (SHIFT .EQ. 3) THEN
		L=9
		R=12
		IF (INTC .LT. 12) R=INTC
C
	END IF
C
C
	DO 400 I=1,16
	DO 400 J=L,INTC
		IF (CT(I,J) .LE. 0) GO TO 400
		SUM=SUM+CT(I,J)
		NSUM=NSUM+1
		INDNC(I)=INDNC(I)+1
		XSUM(I)=XSUM(I)+CT(I,J)
400	CONTINUE
C
C
	IF (NSUM .LE. 0) GO TO 410 
C
	SUM=SUM/NSUM
C
	DAT.CT=SUM
C
C
410	IF (LRE .NE. 0) THEN
C
C
	DO 1400 I=1,16
	DO 1400 J=LRB,LRE
		IF (CTX(I,J) .LE. 0) GO TO 1400
		INDNC(I)=INDNC(I)+1
		XSUM(I)=XSUM(I)+CTX(I,J)
1400	CONTINUE
C
C
C
	ELSE
C
C
C
		DO 699 XMM=1,16
			INDNC(XMM)=0
699			XSUM(XMM)=0
C
	DO 1406 I=1,16
	DO 1406 J=INTC-3,INTC
		IF (CT(I,J) .LE. 0) GO TO 1406
		INDNC(I)=INDNC(I)+1
		XSUM(I)=XSUM(I)+CT(I,J)
1406	CONTINUE
C
C
C
	END IF
C
C
628	DO 3321 I=1,16
C
		IF (INDNC(I) .LE. 0) THEN
			DAT.LCT(I)=0
			GO TO 3321
		END IF
		DAT.LCT(I)=XSUM(I)/INDNC(I)
C
3321	CONTINUE
C
C
C
C
	NSUM=0
	SUM=0
C
	DO 404 I=1,7
	DO 404 J=INTF,INTF
		IF (FT(I,J) .LE. 0) THEN
			DAT.LFT(I)=0
			GO TO 404
		END IF
		SUM=SUM+FT(I,J)
		NSUM=NSUM+1
		DAT.LFT(I)=FT(I,J)
404	CONTINUE
C
C
	IF (NSUM .LE. 0) GO TO 282 
C
	SUM=SUM/NSUM
C
	DAT.FT=SUM
C           
C
ccccccccccccccccccccccccccccccccccccc
c
c	  get flot tail sio2 
C
C
C
457	OPEN (UNIT=91,FILE='MET_P:HALFSIL2.DAT',STATUS='OLD',
	1	ACCESS='KEYED',SHARED,ERR=282)
C
333	READ (91,KEY=KEY(1:4),IOSTAT=M) HSD
C
	CLOSE (91)
	IF (M .NE. 0) GO TO 282
C
C
	READ (KEY(5:6),'(I2)') I
C
	IF (HSD.FLTS(SHIFT,I) .LE. 0) GO TO 6261
C
	DAT.FLFE=-.89484*HSD.FLTS(SHIFT,I)+72.13502
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	   calculate recovery after flotation.
c
c	recov=((flot feed sio2-flot tails sio2)/(avg step comp sio2-flot tails 
c									sio2))
c  	X plant avg. recovery
C
C
C
C	   get avg. plant recov
c
6261	sum=0
	n=0
	do 79 M=1,3
		if (dat.recv(M) .le. 0) go to 79
		n=n+WFACT(M)
		sum=sum+dat.recv(M)*WFACT(M)
79	continue
c
	if (n .eq. 0) go to 282
c
	sum=sum/n
C
c
c	  get avg step composite sio2
c
	x=0
	y=0
	do 80 M=1,2
		if (dat.sil(M+1) .le. 0) go to 80
		if (dat.sil(M+1) .ge. 4.5) go to 80
		x=x+dat.sil(M+1)
		y=y+1
80	continue
c
c
	if (y .le. 0) go to 282
c
c
	X=X/Y
C
C
	IF (DAT.FLSIL .LE. 0 .OR. HSD.FLTS(SHIFT,I) .LE. 0) GO TO 282
C
	DAT.FLREC=((DAT.FLSIL-HSD.FLTS(SHIFT,I))/(X-HSD.FLTS(SHIFT,I)))*SUM
c
C
c
cccccccccccccccccccccc
c
c	calculate recovery ratio
C
	RR=-2*(DAT.FLSIL-X)**2+(DAT.FLSIL-X)+100.
	IF (RR .EQ. 0) GO TO 282
C
	DAT.RRATIO=10000.*((DAT.FLSIL-HSD.FLTS(SHIFT,I))/
	1	(X-HSD.FLTS(SHIFT,I)))/RR
CCCCCCCCCCCCCCC
C
C
282	CONTINUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C	 check if nola vs. target is in control for STEP 2
C
	DAT.SPC2=.TRUE.
	DAT.SPC2S=.TRUE.
C
	OPEN (UNIT=72,FILE='
	1USER_D:[METREP.CSHIFT]NOLA2.DAT',
	1	STATUS='UNKNOWN',FORM='UNFORMATTED',RECL=84,SHARED)
C
	READ (72,ERR=60) ENDATE
	READ (72,ERR=60) XBAR,UCL,LCL,UCLR
	READ (72,ERR=60) XVAL
	READ (72,ERR=60) RVAL
C
	CLOSE (72)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	figure the shift boundaries based on times in endate(42)
C
C
	READ (DAT.DS(7:7),'(I1)') IPS	!get present shift
C
	DO 284 KK=42,1,-1
C
		IF (IPS .EQ. 1) THEN
			IF (ENDATE(KK)(13:17) .GE. SSZ(IPS)) GO TO 284
			IF (ENDATE(KK)(13:17) .LE. ESZ(IPS)) GO TO 284
C
		ELSE IF (IPS .EQ. 2) THEN
			IF (ENDATE(KK)(13:17) .GE. SSZ(IPS) .AND.
	1			ENDATE(KK)(13:17) .LE. ESZ(IPS)) GO TO 284
C
		ELSE IF (IPS .EQ. 3) THEN
			IF (ENDATE(KK)(13:17) .GE. SSZ(IPS) .AND.
	1			ENDATE(KK)(13:17) .LE. ESZ(IPS)) GO TO 284
		ELSE
			GO TO 60
		END IF
C
		NSTART=KK+1
		IF (NSTART .EQ. 43) NSTART=42
		GO TO 285
284	CONTINUE
C
C
285	MINUS6=NSTART-8
C		
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
C
C
	LA=0
	LB=0
 	DO 909 I=34,42
C
C             
		IF (XVAL(I) .GT. XBAR) THEN
			LA=LA+1
			LB=0
			IF (LA .GE. 9) GO TO 98
		ELSE IF (XVAL(I) .LT. XBAR) THEN
			LB=LB+1
			IF (LB .GE. 9) GO TO 98
			LA=0
		ELSE
			LA=0
			LB=0
		END IF
C
C
909	CONTINUE
C
C
C
C
	DO 910 I=42,42
		IF (XVAL(I) .GT. UCL) GO TO 98
		IF (XVAL(I) .LT. LCL) GO TO 98
		IF (RVAL(I) .GT. UCLR) GO TO 98
C
910	CONTINUE
C
	GO TO 160
C
98	DAT.SPC2=.FALSE.
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	   is step 2 in control for the SHIFT?
C
160	LA=0
	LB=0
 	DO 1909 I=MINUS6,42
C
C             
		IF (XVAL(I) .GT. XBAR) THEN
			LA=LA+1
			LB=0
			IF (LA .GE. 9) GO TO 198
		ELSE IF (XVAL(I) .LT. XBAR) THEN
			LB=LB+1
			IF (LB .GE. 9) GO TO 198
			LA=0
		END IF
C
C
1909	CONTINUE
C
C
C
C
	DO 1910 I=NSTART,42
		IF (XVAL(I) .GT. UCL) GO TO 198
		IF (XVAL(I) .LT. LCL) GO TO 198
		IF (RVAL(I) .GT. UCLR) GO TO 198
C
1910	CONTINUE
C
	GO TO 60
C
198	DAT.SPC2S=.FALSE.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
C
C	 check if nola vs. target is in control for STEP 3
C
60	DAT.SPC3=.TRUE.
	DAT.SPC3S=.TRUE.
C
	OPEN (UNIT=72,FILE='
	1USER_D:[METREP.CSHIFT]NOLA3.DAT',
	1	STATUS='UNKNOWN',FORM='UNFORMATTED',RECL=84,SHARED)
C
	READ (72,ERR=188) ENDATE
	READ (72,ERR=188) XBAR,UCL,LCL,UCLR
	READ (72,ERR=188) XVAL
	READ (72,ERR=188) RVAL
C
	CLOSE (72)
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	figure the shift boundaries based on times in endate(42)
C
C
	READ (DAT.DS(7:7),'(I1)') IPS	!get present shift
C
	DO 6284 KK=42,1,-1
C
		IF (IPS .EQ. 1) THEN
			IF (ENDATE(KK)(13:17) .GE. SSZ(IPS)) GO TO 6284
			IF (ENDATE(KK)(13:17) .LE. ESZ(IPS)) GO TO 6284
C
		ELSE IF (IPS .EQ. 2) THEN
			IF (ENDATE(KK)(13:17) .GE. SSZ(IPS) .AND.
	1			ENDATE(KK)(13:17) .LE. ESZ(IPS)) GO TO 6284
C
		ELSE IF (IPS .EQ. 3) THEN
			IF (ENDATE(KK)(13:17) .GE. SSZ(IPS) .AND.
	1			ENDATE(KK)(13:17) .LE. ESZ(IPS)) GO TO 6284
		ELSE
			GO TO 188
		END IF
C
		NSTART=KK+1
		IF (NSTART .EQ. 43) NSTART=42
		GO TO 6285
C
6284	CONTINUE
C
C
6285	MINUS6=NSTART-8
C		
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
	LA=0
	LB=0
 	DO 2909 I=34,42
C
C             
		IF (XVAL(I) .GT. XBAR) THEN
			LA=LA+1
			LB=0
			IF (LA .GE. 9) GO TO 298
		ELSE IF (XVAL(I) .LT. XBAR) THEN
			LB=LB+1
			LA=0
			IF (LB .GE. 9) GO TO 298
		ELSE
			LA=0
			LB=0
		END IF
C
C
2909	CONTINUE
C
C
C
C
	DO 2910 I=42,42
		IF (XVAL(I) .GT. UCL) GO TO 298
		IF (XVAL(I) .LT. LCL) GO TO 298
		IF (RVAL(I) .GT. UCLR) GO TO 298
C
2910	CONTINUE
C
	GO TO 1887
C
298	DAT.SPC3=.FALSE.
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	   is step 3 in control for SHIFT?
C
C
1887	LA=0
	LB=0
 	DO 3909 I=MINUS6,42
C
C             
		IF (XVAL(I) .GT. XBAR) THEN
			LA=LA+1
			LB=0
			IF (LA .GE. 9) GO TO 398
		ELSE IF (XVAL(I) .LT. XBAR) THEN
			LB=LB+1
			LA=0
			IF (LB .GE. 9) GO TO 398
		END IF
C
C
3909	CONTINUE
C
C
C
C
	DO 3910 I=NSTART,42
		IF (XVAL(I) .GT. UCL) GO TO 398
		IF (XVAL(I) .LT. LCL) GO TO 398
		IF (RVAL(I) .GT. UCLR) GO TO 398
C
3910	CONTINUE
C
	GO TO 188
C
398	DAT.SPC3S=.FALSE.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
188	CONTINUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
	DCNT=1
C
	DO 226 LN=1,16
	DO 126 NC=1,20
C
		IF (DLY.SST(1,1,LN,NC) .EQ. 0) GO TO 226
C
		MSAVE=0
		DO 585 M=1,40
			IF (DAT.INDEX(1,M) .EQ. LN) THEN
				IF (DAT.INDEX(2,M) .EQ. NC) THEN
					DCNT=M
					MSAVE=M
					GO TO 545
				END IF
			ELSE IF (DAT.INDEX(1,M) .EQ. 0) THEN
                        	IF (MSAVE .EQ. 0) THEN
					MSAVE=M
					DCNT=M
					GO TO 58
				END IF
			END IF
585		CONTINUE
C
C
C
C
C
58	DAT.DELAYS(DCNT)=
	1	'          U                                        '
C
545			CALL SYS$ASCTIM (,STPTM,DAT.SST(1,1,LN,NC),)
C
C
			IF (DAT.SST(1,2,LN,NC) .NE. 0) THEN
			CALL SYS$ASCTIM (,STRTM,DAT.SST(1,2,LN,NC),)
C
			else
C
			STRTM='                       '
c
			END IF
C
	DAT.INDEX(1,MSAVE)=LN
	DAT.INDEX(2,MSAVE)=NC
C				
	WRITE (ALN,'(I2)') LN+2
	DAT.DELAYS(DCNT)=ALN//STPTM(13:14)//stptm(16:17)//
	1	STRTM(13:14)//strtm(16:17)//DAT.DELAYS(DCNT)(11:64)
C
C
C
126	CONTINUE
C
C
226	CONTINUE
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	  sort the delay messages in line and index order
C
C
773	DO 714 I=1,39
		DO 713 J=I+1,40
C
		SAVE=DAT.DELAYS(I)
		SAVEINDEX(1)=DAT.INDEX(1,I)   ! line no.
		SAVEINDEX(2)=DAT.INDEX(2,I)   ! relative index within line no.
C
	IF (DAT.DELAYS(J)(1:2) .LE. '  '.OR.DAT.DELAYS(J)(1:1).GT.'9')GO TO 714
		IF (DAT.DELAYS(J)(1:2).GE.'22'.AND.DAT.DELAYS(I)(1:2).LT.'14')
	1		THEN
				DAT.DELAYS(I)=DAT.DELAYS(J)
				DAT.INDEX(1,I)=DAT.INDEX(1,J)
				DAT.INDEX(2,I)=DAT.INDEX(2,J)
				DAT.DELAYS(J)=SAVE
				DAT.INDEX(1,J)=SAVEINDEX(1)
				DAT.INDEX(2,J)=SAVEINDEX(2)
				GO TO 713
			END IF
			IF (DAT.DELAYS(J)(1:2) .LT. DAT.DELAYS(I)(1:2)) THEN
				DAT.DELAYS(I)=DAT.DELAYS(J)
				DAT.INDEX(1,I)=DAT.INDEX(1,J)
				DAT.INDEX(2,I)=DAT.INDEX(2,J)
				DAT.DELAYS(J)=SAVE
				DAT.INDEX(1,J)=SAVEINDEX(1)
				DAT.INDEX(2,J)=SAVEINDEX(2)
			END IF
C
713		CONTINUE
C
714	CONTINUE
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C	  put delays in time order
C
C
C
C
	DO 786 I=1,39
	DO 785 J=I+1,40
		IF (DAT.DELAYS(I)(1:2) .EQ. DAT.DELAYS(J)(1:2)) THEN
			IF ((DAT.DELAYS(I)(3:6) .GE. '2230') .AND.
	1		(DAT.DELAYS(J)(3:6) .GE. '2230')) THEN	!3
C
			IF (DAT.DELAYS(J)(3:6) .LT. DAT.DELAYS(I)(3:6)) 	
	1			GO TO 1122
C
			ELSE IF ((DAT.DELAYS(I)(3:6) .GE. '2230') .AND.
	1		(DAT.DELAYS(J)(3:6) .LT. '2230')) THEN	!3
				GO TO 785
C
			ELSE IF ((DAT.DELAYS(I)(3:6) .LT. '2230') .AND.
	1		(DAT.DELAYS(J)(3:6) .GE. '2230')) THEN	!3
				GO TO 1122
C
C
			ELSE IF ((DAT.DELAYS(I)(3:6) .LT. '2230') .AND.
	1		(DAT.DELAYS(J)(3:6) .LT. '2230')) THEN	!3
			IF (DAT.DELAYS(J)(3:6) .LT. DAT.DELAYS(I)(3:6)) 	
	1			GO TO 1122
C
C
			END IF
C
		END IF  	
C
	GO TO 785
C
1122		SAVE=DAT.DELAYS(I)
		SAVEINDEX(1)=DAT.INDEX(1,I)   ! line no.
		SAVEINDEX(2)=DAT.INDEX(2,I)   ! relative index within line no.
				DAT.DELAYS(I)=DAT.DELAYS(J)
				DAT.INDEX(1,I)=DAT.INDEX(1,J)
				DAT.INDEX(2,I)=DAT.INDEX(2,J)
				DAT.DELAYS(J)=SAVE
				DAT.INDEX(1,J)=SAVEINDEX(1)
				DAT.INDEX(2,J)=SAVEINDEX(2)
785	CONTINUE
786	CONTINUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
c		sort the mill down messages
C
C
C
	M=1
C
	do 8601 I=1,167
C
	IF (DAT.MDOWN(I)(1:6) .le. '     ') GO TO 8601
	SAVMD=DAT.MDOWN(I)
C
	DO 8600 J=I+1,168
C
	IF (DAT.MDOWN(J)(1:6) .le. '     ') GO TO 8600
	IF (DAT.MDOWN(J)(5:6) .LT. SAVMD(5:6)) THEN
		DAT.MDOWN(I)=DAT.MDOWN(J)
		DAT.MDOWN(J)=SAVMD
		SAVMD=DAT.MDOWN(I)
	END IF
C
8600	CONTINUE
C
	MX(M)=DAT.MDOWN(I)
	M=M+1
8601	CONTINUE
C
	DO 8602 I=1,168
8602		DAT.MDOWN(I)=MX(I)
C
C
	DO 378 I=1,168
378		MX(I)='                                        '
C
C
CCCCCCCCCCCCCCCCCCCCCCC
C
C		PUT MSGS' IN EQUIP ORDER
C
	M=1
C
	do 9401 I=1,167
C
	IF (DAT.MDOWN(I)(1:6) .le. '      ') GO TO 9401
	SAVMD=DAT.MDOWN(I)
C
	DO 9400 J=I+1,168
C
	IF (DAT.MDOWN(J)(1:6) .le. '      ') GO TO 9400
	IF (DAT.MDOWN(J)(5:6) .EQ. SAVMD(5:6)) THEN
	IF (DAT.MDOWN(J)(1:3) .LT. SAVMD(1:3)) THEN
		DAT.MDOWN(I)=DAT.MDOWN(J)
		DAT.MDOWN(J)=SAVMD
		SAVMD=DAT.MDOWN(I)
	END IF
	END IF
C
9400	CONTINUE
C
	MX(M)=DAT.MDOWN(I)
	M=M+1
9401	CONTINUE
C
	DO 9402 I=1,168
9402		DAT.MDOWN(I)=MX(I)
C
C
C
	IF (MM .EQ. 36) THEN
		WRITE (10) DAT
	ELSE IF (MM .EQ. 0) THEN
		REWRITE (10) DAT
	END IF
C
	END
	FUNCTION STAT(J)
	INTEGER CXSTS(100),K,L
 	INTEGER*2 STAT
	COMMON /CONTACTSCNC/CXSTS
	K=J/32+1
	L=MOD(J,32)
	IF (BJTEST(CXSTS(K),L)) THEN
		STAT=1
	ELSE
		STAT=0
	END IF
	END
